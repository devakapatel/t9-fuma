---
title: Practical 2
---

## AIM: Create a scenario in CloudSim to create a datacenter along with one host. Also create one virtual machine with static configuration to run one cloudlet on it.

## THEORY:

### 2A. CloudSim Setup using Eclipse

CloudSim is a standalone toolkit that allows us to simulate the cloud functionality on any commodity machine. This toolkit is developed using JAVA programming language and is an extensible framework.

Requirements for CloudSim Projects:

- Integrated Development Environment (IDE):
  - Java Development Kit (JDK)
  - Eclipse/NetBeans IDE

- Operating System (OS):
  - Windows Vista (32 or 64 bit)
  - Windows 7 (32 or 64 bit)
  - Windows 8 and 10 (32 or 64 bit)
  - Windows XP (32 bit)
  - Mac OS X 10.5.8 or later (32 bit only)
  - Linux (Lucid Lynx and Ubuntu Linux)

Steps for Setup:

- Step 1 (Java Development Kit - JDK): The latest version of Java (JDK) should be installed, which can be downloaded from Oracle's Java portal.
- Step 2 (CloudSim Download): Download the CloudSim 3.0.3 zip file from GitHub and extract the folders within a folder named CloudSimSetup in your computer storage.
- Step 3 (Apache Commons Math): Download Apache Commons Math 3.6.1 bin-zip file and extract the folders within the CloudSimSetup folder. Cut & paste commons-math3-3.6.1.jar file into the CloudSimSetup folder, as it provides a faster, more accurate alternative to regular Math classes for large-scale computation in Java.
- Step 4 (Create Project in Eclipse): Open Eclipse IDE and create a new Java Project named CloudSimSampleSetup. Untick UseDefaultLocation. Select the folder path where CloudSim-3.0.3 is extracted till cloudsim-3.0.3. Click on Next.
- Step 5 (Add External JARs): In the JAVA Settings window, select the Libraries tab. Click on Add External JARs. The JAR file commons-math3-3.6.1.jar from the extracted Apache Commons Math folder needs to be added to the JAR files of CloudSim.
- Step 6 (Finish Setup): Click on Finish. Now the CloudSim Environment has been set up in the Eclipse IDE.

STEPS to implement the AIM:
- Initialize the CloudSim package.
- Create Data Centers.
- Create Broker.
- Create one virtual machine.
- Create one Cloudlet.
- Starts the simulation.
- Print results when simulation is over.

Steps needed to create a PowerDatacenter:
- We need to create a list to store the machines.
- A Machine contains one or more PEs or CPUs/Cores.
- Create PEs and add these into a list.
- Create Host with its id and list of PEs and add them to the list of machines.
- Create a Datacenter Characteristics object that stores the properties of a data center: architecture, OS, list of Machines, allocation policy (time- or space-shared), time zone and its price (G$/Pe time unit).
- Finally, we need to create a PowerDatacenter object.

### 2B. CONCLUSION:

We have successfully created a datacenter along with one host. Also created one virtual machine with static configuration to run one cloudlet on it.

### 2C. Cloud Computing Simulation using CloudSim

CloudSim lets the user design and imitate the cloud system entities. For modeling cloud simulation, some of the main classes and their functionalities are:
- To simulate the workloads: org.cloudbus.cloudsim → "Cloudlet.java"
- To simulate the regions and datacenters: org.cloudbus.cloudsim → "Datacenter.java"
- To simulate the task offloading and policy-related services: org.cloudbus.cloudsim → "VmAllocationPolicy.java", "CloudletScheduler.java", "DatacenterBroker.java", etc.

### CODE:

The Java code for CloudSimExample1.java demonstrating the AIM:

```java title="CloudSimExample1.java"
package org.cloudbus.cloudsim.examples;

/*
 * Title: CloudSim Toolkit
 * Description: CloudSim (Cloud Simulation) Toolkit for Modeling and Simulation of Clouds
 * Licence: GPL - http://www.gnu.org/copyleft/gpl.html
 * Copyright (c) 2009, The University of Melbourne, Australia
 */
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.LinkedList;
import java.util.List;
import org.cloudbus.cloudsim.Cloudlet;
import org.cloudbus.cloudsim.CloudletSchedulerTimeShared;
import org.cloudbus.cloudsim.Datacenter;
import org.cloudbus.cloudsim.DatacenterBroker;
import org.cloudbus.cloudsim.DatacenterCharacteristics;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.UtilizationModel;
import org.cloudbus.cloudsim.UtilizationModelFull;
import org.cloudbus.cloudsim.Vm;
import org.cloudbus.cloudsim.VmAllocationPolicySimple;
import org.cloudbus.cloudsim.VmSchedulerTimeShared;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.provisioners.BwProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;

/**
 * A simple example showing how to create a data center with one host and run one
 * cloudlet on it.
 */
public class CloudSimExample1 {
	/** The cloudlet list. */
	private static List<Cloudlet> cloudletList;

	/** The vmlist. */
	private static List<Vm> vmlist;

	/**
	 * Creates main() to run this example.
	 *
	 * @param args the args
	 */
	@SuppressWarnings("unused")
	public static void main(String[] args) {
		Log.printLine("Starting CloudSimExample1...");
		try {
			// First step: Initialize the CloudSim package. It should be called
			// before creating any entities.
			int num_user = 1; // number of cloud users
			Calendar calendar = Calendar.getInstance(); // Calendar whose
			// fields have been initialized with the current date and time.
			boolean trace_flag = false; // trace events

			CloudSim.init(num_user, calendar, trace_flag);

			// Second step: Create Datacenters
			// Datacenters are the resource providers in CloudSim. We need at
			// list one of them to run a CloudSim simulation
			Datacenter datacenter0 = createDatacenter("Datacenter_0");

			// Third step: Create Broker
			DatacenterBroker broker = createBroker();
			int brokerId = broker.getId();

			// Fourth step: Create one virtual machine
			vmlist = new ArrayList<Vm>();

			// VM description
			int vmid = 0;
			int mips = 1000;
			long size = 10000; // image size (MB)
			int ram = 512; // vm memory (MB)
			long bw = 1000;
			int pesNumber = 1; // number of cpus
			String vmm = "Xen"; // VMM name

			// create VM
			Vm vm = new Vm(vmid, brokerId, mips, pesNumber, ram, bw,
					size, vmm, new CloudletSchedulerTimeShared());

			// add the VM to the vmList
			vmlist.add(vm);

			// submit vm list to the broker
			broker.submitVmList(vmlist);

			// Fifth step: Create one Cloudlet
			cloudletList = new ArrayList<Cloudlet>();

			// Cloudlet properties
			int id = 0;
			long length = 400000;
			long fileSize = 300;
			long outputSize = 300;
			UtilizationModel utilizationModel = new UtilizationModelFull();

			Cloudlet cloudlet =
				new Cloudlet(id, length, pesNumber, fileSize,
					outputSize, utilizationModel, utilizationModel,
					utilizationModel);
			cloudlet.setUserId(brokerId);
			cloudlet.setVmId(vmid);

			// add the cloudlet to the list
			cloudletList.add(cloudlet);

			// submit cloudlet list to the broker
			broker.submitCloudletList(cloudletList);

			// Sixth step: Starts the simulation
			CloudSim.startSimulation();

			CloudSim.stopSimulation();

			//Final step: Print results when simulation is over
			List<Cloudlet> newList = broker.getCloudletReceivedList();
			printCloudletList(newList);

			Log.printLine("CloudSimExample1 finished!");
		}
		catch (Exception e) {
			e.printStackTrace();
			Log.printLine("Unwanted errors happen");
		}
	}

	/**
	 * Creates the datacenter.
	 *
	 * @param name the name
	 *
	 * @return the datacenter
	 */
	private static Datacenter createDatacenter(String name) {

		// Here are the steps needed to create a PowerDatacenter:
		// 1. We need to create a list to store
		// our machine
		List<Host> hostList = new ArrayList<Host>();

		// 2. A Machine contains one or more PEs or CPUs/Cores.
		// In this example, it will have only one core.
		List<Pe> peList = new ArrayList<Pe>();
		int mips = 1000;

		// 3. Create PEs and add these into a list.
		peList.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store
		// Pe id and MIPS Rating

		// 4. Create Host with its id and list of PEs and add them to the list
		// of machines
		int hostId = 0;
		int ram = 2048; // host memory (MB)
		long storage = 100000; // host storage
		int bw = 10000;

		hostList.add(
			new Host(
				hostId,
				new RamProvisionerSimple(ram),
				new BwProvisionerSimple(bw),
				storage,
				peList,
				new VmSchedulerTimeShared(peList)
			)
		); // This is our machine

		// 5. Create a Datacenter Characteristics object that stores the
		// properties of a data center: architecture, OS, list of
		// Machines, allocation policy: time- or space-shared, time zone
		// and its price (G$/Pe time unit).
		String arch = "x86"; // system architecture
		String os = "Linux"; // operating system
		String vmm = "Xen";
		double time_zone = 10.0; // time zone this resource located
		double cost = 3.0; // the cost of using processing in this resource
		double costPerMem = 0.05; // the cost of using memory in this resource
		double costPerStorage = 0.001; // the cost of using storage in this
		// resource
		double costPerBw = 0.0; // the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>(); // we are
		// not adding SAN devices by now

		DatacenterCharacteristics characteristics = new DatacenterCharacteristics(
				arch, os, vmm, hostList, time_zone, cost, costPerMem,
				costPerStorage, costPerBw);

		// 6. Finally, we need to create a PowerDatacenter object.
		Datacenter datacenter = null;
		try {
			datacenter = new Datacenter(name, characteristics, new
					VmAllocationPolicySimple(hostList), storageList, 0);
		} catch (Exception e) {
			e.printStackTrace();
		}

		return datacenter;
	}

	// We strongly encourage users to develop their own broker policies, to
	// submit vms and cloudlets according
	// to the specific rules of the simulated scenario
	/**
	 * Creates the broker.
	 *
	 * @return the datacenter broker
	 */
	private static DatacenterBroker createBroker() {
		DatacenterBroker broker = null;
		try {
			broker = new DatacenterBroker("Broker");
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
		return broker;
	}

	/**
	 * Prints the Cloudlet objects.
	 *
	 * @param list list of Cloudlets
	 */
	private static void printCloudletList(List<Cloudlet> list) {
		int size = list.size();
		Cloudlet cloudlet;

		String indent = " ";
		Log.printLine();
		Log.printLine("========== OUTPUT==========");
		Log.printLine("Cloudlet ID" + indent + "STATUS" + indent
				+ "Data center ID" + indent + "VM ID" + indent + "Time"
				+ indent + "Start Time" + indent + "Finish Time");
		DecimalFormat dft = new DecimalFormat("###.##");
		for (int i = 0; i < size; i++) {
			cloudlet = list.get(i);
			Log.print(indent + cloudlet.getCloudletId() + indent + indent);

			if (cloudlet.getCloudletStatus() == Cloudlet.SUCCESS) {
				Log.print("SUCCESS");

				Log.printLine(indent + indent + cloudlet.getResourceId()
						+ indent + indent + indent + cloudlet.getVmId()
						+ indent + indent + dft.format(cloudlet.getActualCPUTime())
						+ indent + indent + dft.format(cloudlet.getExecStartTime())
						+ indent + indent + dft.format(cloudlet.getFinishTime()));
			}
		}
	}
}
```

### Output:

The console output from running CloudSimExample1:

```
Starting CloudSimExample1...
Initialising..
Starting CloudSim version 3.0
Datacenter_0 is starting..
Broker is starting...
Entities started.
0.2: Broker: Cloud Resource List received with 1 resource(s)
0.2: Broker: Trying to Create VM #0 in Datacenter #2
0.4: Broker: VM #0 has been created in Datacenter #2, Host #0
0.4: Broker: Sending cloudlet 0 to VM #0
400.4: Broker: Cloudlet 0 received
400.4: Broker: All Cloudlets executed. Finishing...
400.4: Broker: Destroying VM #0
Broker is shutting down...
Simulation: No more future events
CloudInformationService: Notify all CloudSim entities for shutting down.
Datacenter_0 is shutting down...
Broker is shutting down...
Simulation completed.
Simulation completed.

========== OUTPUT==========
Cloudlet ID  STATUS  Data center ID  VM ID  Time  Start Time  Finish Time
 0  SUCCESS  2  0  400  0.4  400.4
CloudSimExample1 finished!
```

### Explanation of the Code:

- Initialization: The CloudSim.init() method sets up the CloudSim environment.
- Datacenter Creation (createDatacenter):
  - Datacenter Characteristics: Defines the architecture, OS, VMM, costs, and storage of the datacenter.
  - Host: Creates a physical host with specified PEs, RAM, bandwidth, and storage. A VmSchedulerTimeShared is used, determining how VMs share the host's PEs.
  - VmAllocationPolicySimple: A policy that allocates VMs to the first available host.
  - The Datacenter object is instantiated with these components.

- Host Creation (within createDatacenter):
  - Pe: Represents a processing element (CPU core). A PeProvisionerSimple allocates PEs to VMs.
  - The Host is created with resource provisioners for RAM (RamProvisionerSimple) and bandwidth (BwProvisionerSimple).

- VM Creation (in main method):
  - Vm: Defines the virtual machine with an ID, user ID, number of PEs, RAM, bandwidth, storage, VMM, and a CloudletSchedulerTimeShared that manages how cloudlets are executed on the VM's PEs.

- Cloudlet Creation (in main method):
  - Cloudlet: Represents the task to be executed. It includes ID, length (in MI), required PEs, input/output file sizes, and utilization models.
  - UtilizationModelFull indicates constant full utilization.

- Broker Creation (createBroker):
  - DatacenterBroker: Acts on behalf of the user, submitting VMs and cloudlets to the datacenter.

- Submission and Simulation:
  - broker.submitVmList(vmList): Sends the created VMs to the broker.
  - broker.submitCloudletList(cloudletList): Sends the created cloudlets to the broker.
  - CloudSim.startSimulation(): Begins the simulation.
  - CloudSim.stopSimulation(): Ends the simulation.

- Result Printing (printCloudletList): Displays details of the executed cloudlet, such as its ID, status, execution time, start time, and finish time.
